#!/usr/bin/env python
from __future__ import unicode_literals, print_function

import itertools as it, operator as op, functools as ft
from os.path import basename, dirname
from collections import OrderedDict, namedtuple
import os, sys, types, errno, stat, re, logging

from skydrive import api_v5, conf
import fuse


from datetime import datetime, timedelta
from calendar import timegm
try:
	import iso8601
	def parse_ts(ts):
		return timegm(iso8601.parse_date(ts).utctimetuple())
except ImportError:
	def parse_ts(ts):
		try: (ts, tz), tz_mul = ts.rsplit('+', 1), 1
		except ValueError: (ts, tz), tz_mul = ts.rsplit('-', 1), -1
		ts_utc = datetime.strptime(ts, '%Y-%m-%dT%H:%M:%S')
		ts_utc += timedelta(0, (int(tz[:2])*3600 + int(tz[2:])*60) * tz_mul)
		return timegm(ts_utc.utctimetuple())



class CacheLRU(object):

	CE = namedtuple('CachedException', 'err')
	hits = misses = 0

	def __init__(self, func, cache_exceptions=True, maxsize=100):
		self.func, self.maxsize, self.ce = func, maxsize, cache_exceptions
		self.cache = OrderedDict()

	@staticmethod
	def _key(argz, kwz):
		return kwz.pop('_cache_key', False)\
			or (argz + tuple(sorted(kwz.viewitems())))

	def __call__(self, *argz, **kwz):
		key = self._key(argz, kwz)
		try:
			res = self.cache.pop(key)
			self.hits += 1
		except KeyError:
			try: res = self.func(*argz, **kwz)
			except Exception as err:
				if not self.ce: raise
				res = self.CE(err)
			self.misses += 1
			while len(self.cache) >= self.maxsize:
				self.cache.popitem(0)
		self.cache[key] = res
		if isinstance(res, self.CE): raise res.err
		else: return res

	def purge(self, *argz, **kwz):
		self.cache.pop(self._key(argz, kwz), None)


class PerPathCache(CacheLRU):
	@staticmethod
	def _key(argz, kwz): return argz[0]
	def __call__(self, path):
		return super(PerPathCache, self).__call__(path)
	def purge(self, path):
		return super(PerPathCache, self).purge(path)



class SkyDriveFS(fuse.LoggingMixIn, fuse.Operations):


	def __init__( self,
			api, root='me/skydrive', log=None,
			api_cache=True, api_cache_scale=1.0 ):

		self.api, self.root = api, root
		self.log = log or logging.getLogger(
			'{}.{}'.format(__name__, self.__class__.__name__) )

		if api_cache and api_cache_scale > 0:
			self._resolve = PerPathCache(
				self.api.resolve_path, maxsize=int(200 * api_cache_scale) )
			self._info = PerPathCache(
				self.api.info, maxsize=int(100 * api_cache_scale) )
			self._listdir = PerPathCache(
				self.api.listdir, maxsize=int(50 * api_cache_scale) )
		else:
			self._resolve, self._info, self._listdir =\
				self.api.resolve_path, self.api.info, self.api.listdir

	def _purge(self, *entries, **kwz):
		caches = kwz.keys() or ['info', 'listdir']
		for entry in entries:
			if isinstance(entry, types.StringTypes): ec = [caches]
			else: entry, ec = entry
			for cache in ec: op.attrgetter('_{}.purge'.format(cache))(self)(entry)


	def __call__(self, op, *args):
		try: res = super(SkyDriveFS, self).__call__(op, *args)
		except api_v5.DoesNotExists:
			raise fuse.FuseOSError(errno.ENOENT)
		except api_v5.ProtocolError:
			if err.code in [401, 403]: raise fuse.FuseOSError(errno.EACCES)
			elif err.code == 404: raise fuse.FuseOSError(errno.ENOENT)
			raise
		return 0 if res is None else res


	def access(self, path, mode):
		self._resolve(path)

	def getattr(self, path, fh=None):
		obj = self._info(self._resolve(path))
		obj_mtime = obj.get('updated_time') or obj.get('created_time')
		return dict( (k,v) for k,v in [
			( 'st_mode', (stat.S_IFDIR | 0755)
				if obj['type'] in ['folder', 'album'] else (stat.S_IFREG | 0644) ),
			('st_mtime', obj_mtime and parse_ts(obj_mtime)),
			('st_nlink', 2), ('st_size', obj.get('size')) ] if v is not None )

	def mkdir(self, path, mode):
		name, parent = basename(path),\
			self._resolve(dirname(path)) or self.root
		self.api.mkdir(name, parent)
		self._purge(parent)

	def readdir(self, path, fh):
		return ['.', '..'] + map( op.itemgetter('name'),
			self._listdir(self._resolve(path)) )

	def rename(self, old, new):
		if old == new: return
		new_dir, old_dir = dirname(new), dirname(old)
		old_id = self._resolve(old)
		if new_dir != old_dir:
			self.api.move(old_id, self._resolve(new_dir))
			self._purge(old_dir, (old, 'resolve'))
		self.api.info_update(old_id, dict(name=basename(new)))
		self._purge(new_dir)

	def rmdir(self, path):
		path_id = self._resolve(path)
		if not path_id.startswith('folder.'):
			raise fuse.FuseOSError(errno.ENOTDIR)
		elif self._listdir(path_id):
			raise fuse.FuseOSError(errno.ENOTEMPTY)
		self.api.delete(path_id)
		self._purge(dirname(path), (path, 'resolve'))

	def statfs(self, path):
		free, quota = self.api.get_quota()
		return dict( f_bavail=quota-free, f_bfree=free,
			f_blocks=quota, f_bsize=1, f_favail=-1, f_ffree=-1,
			f_files=-1, f_flag=0, f_frsize=1, f_namemax=256 )

	def unlink(self, path):
		path_id = self._resolve(path)
		if path_id.startswith('folder.'):
			raise fuse.FuseOSError(errno.EISDIR)
		self.api.delete(path_id)
		self._purge(dirname(path), (path, 'resolve'))




def main():
	opts_fs = dict(api_cache=True, api_cache_scale=1.0)
	opts_fuse = dict(foreground=True)

	import argparse
	parser = argparse.ArgumentParser(
		description='Mount SkyDrive as a FUSE filesystem.')
	parser.add_argument('config',
		metavar='config_path[:skydrive_path]',
		nargs='?', default=conf.ConfigMixin.conf_path_default,
		help='Writable configuration state-file (yaml).'
			' Used to store authorization_code, access and refresh tokens.'
			' Should initially contain at least something like "{client: {id: xxx, secret: yyy}}".'
			' Default: %(default)s')
	parser.add_argument('mountpoint', metavar='path', help='Path to mount SkyDrive to.')
	parser.add_argument('-o', '--mount-options',
		help=''.join([ 'Comma-separated list of mount options.',
			' Use "someflag=no", or "someflag=false" to disable binary flags.',
			' SkyDriveFS options: {};'\
				.format( ', '.join('{} (default: {})'.format(k, v)
					for k,v in sorted(opts_fs.viewitems())) ),
				' the rest is passed to fuse.',
			' See "man mount.fuse" for the list of fuse-specific options.' ]))
	parser.add_argument('--debug', action='store_true', help='Verbose operation mode.')
	optz = parser.parse_args()

	log = logging.getLogger()
	logging.basicConfig(level=logging.WARNING
		if not optz.debug else logging.DEBUG)

	if optz.mount_options:
		for opt in optz.mount_options.strip().strip(',').split(','):
			if '=' in opt: opt, val = opt.split('=', 1)
			# elif opt.startswith('no_'): opt, val = opt[3:], False
			else: val = True
			if opt in ['api_cache']: # binary flags
				if isinstance(val, types.StringTypes):
					if val.lower() in ['yes', 'true', 'y']: val = True
					elif val.lower() in ['no', 'false', 'n']: val = False
					else: parser.error('Unrecognized flag ({!r}) value: {!r}'.format(opt, val))
				opts_fs[opt] = val
			elif opt in ['api_cache_scale']: # numeric options
				opts_fs[opt] = float(val)
			else: opts_fuse[opt] = val
	log.debug('FS options: {}; FUSE: {}'.format(opts_fs, opts_fuse))

	if ':' in optz.config:
		optz.config, skydrive_path = optz.config.split(':', 1)
	else: skydrive_path = None

	api = api_v5.PersistentSkyDriveAPI.from_conf(optz.config)
	if not skydrive_path or not re.search(
			r'^(file|folder)\.[0-9a-f]{16}\.[0-9A-F]{16}!\d+'
			r'|folder\.[0-9a-f]{16}$', skydrive_path ):
		skydrive_path = api.resolve_path(skydrive_path or 'me/skydrive')

	fuse.FUSE(
		SkyDriveFS(api, skydrive_path, log=log, **opts_fs),
		optz.mountpoint, **opts_fuse )

if __name__ == '__main__': main()
